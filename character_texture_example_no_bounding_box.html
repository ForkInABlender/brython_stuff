<!DOCTYPE html>

<!-- Dylan Kenneth Eliot & gpt-4-plugins


Most of this was structured by GPT-4. The minor edits I did was to correct syntax. Mostly, it looks at a single part of the image.
The camera view could be bound to a key event press that would normally allow for a way to change perspective views. Or rather, allow one to
 define a custom event handler that changed the camera angle and depth based on either or not an object was behind that camera.
This is designed mostly to show-case how it can be done for templating a texture for a character before adding in the funny logic.

The working proof of concept helps build a functional equivalent. This __should__ outline how to template from a 2d canvas before applying it as
 a texture on a body part of the character "doll" for the player. There is a way to detect collision events on a player and object. 

If done right, one could implement one's own collision rules, game commands, etcetera.

The world is as, at that point, how you define it and as limited as you imagine it not being. 


-->

<html>
<head>
    <meta charset="UTF-8">
    <title>Minecraft Character</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.11.3/brython.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.11.3/brython_stdlib.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body onload="brython()">
    <input id="file_input" type="file">
    <script type="text/python">
        from browser import document, html, window, timer

        FileReader = window.FileReader
        THREE = window.THREE
        scene = THREE.Scene.new()
        camera = THREE.PerspectiveCamera.new(75, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.z = 5
        #camera.position.y = 2
        
        renderer = THREE.WebGLRenderer.new()
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)

        def read_file(evt):
            file = document["file_input"].files[0]
            reader = FileReader.new()
            def onload(event):
                # create an onload event handler
                # take in a target image
                img = html.IMG(src=event.target.result)
                def img_onload(event):
                    # On load of that image, segment that image
                    #  and grab from a 2d canvas a chunk of that image
                    # Take that chunk and use it as a texture
                    canvas = html.CANVAS(width=8, height=8)
                    ctx = canvas.getContext('2d')
                    ctx.drawImage(img, -8, -8)
                    imgData = ctx.getImageData(0, 0, 8, 8)
                    ctx.putImageData(imgData, 0, 0)
                    texture = THREE.Texture.new(canvas)
                    texture.needsUpdate = True
                    material = THREE.MeshBasicMaterial.new({"map": texture})
                    
                    head = THREE.Mesh.new(THREE.BoxGeometry.new(1, 1, 1), material)
                    body = THREE.Mesh.new(THREE.BoxGeometry.new(0.8, 1.2, 0.4), material)
                    leftArm = THREE.Mesh.new(THREE.BoxGeometry.new(0.4, 1, 0.4), material)
                    rightArm = THREE.Mesh.new(THREE.BoxGeometry.new(0.4, 1, 0.4), material)
                    leftLeg = THREE.Mesh.new(THREE.BoxGeometry.new(0.4, 1, 0.4), material)
                    rightLeg = THREE.Mesh.new(THREE.BoxGeometry.new(0.4, 1, 0.4), material)
                    

                    head.position.y = 2.2
                    body.position.y = 1.2
                    
                    leftArm.position.x = -0.6
                    leftArm.position.y = 1.2
                    rightArm.position.x = 0.6
                    rightArm.position.y = 1.2
                    leftLeg.position.y = 0.1
                    leftLeg.position.x = -0.2
                    rightLeg.position.y = 0.1
                    rightLeg.position.x = 0.2
                    
                    character = THREE.Group.new()
                    character.add(head)
                    #character.add(camera)
                    character.add(body)
                    character.add(leftArm)
                    character.add(rightArm)
                    character.add(leftLeg)
                    character.add(rightLeg)
                    
                    scene.add(character)
                    # 
                    # Animate the scene
                    # 
                    def animate(timestamp):
                        character.rotation.y += 0.01
                        
                        
                        renderer.render(scene, camera)
                        timer.request_animation_frame(animate)
                    ###
                    timer.request_animation_frame(animate)
                img.bind('load', img_onload)            
            reader.bind("load", onload)
            reader.readAsDataURL(file)

        document["file_input"].bind("change", read_file)
    </script>
</body>
</html>
